# ResultSet 


# 1) What is `ResultSet`?

* `ResultSet` is the JDBC object that holds the tabular results returned by executing a `Statement` / `PreparedStatement` / `CallableStatement`.
* It represents a **cursor** over rows from a query. You use `getXxx(...)` methods to read column values.
* Cursor position starts before the first row. Use navigation methods (e.g., `next()`) to move it.

---

# 2) How a `ResultSet` is created

* From a `Statement` / `PreparedStatement` / `CallableStatement`:

  ```java
  Statement st = con.createStatement();
  ResultSet rs = st.executeQuery("SELECT id, name FROM students");
  ```
* You can request scrollability & concurrency when creating the `Statement`:

  ```java
  Statement st = con.createStatement(
      ResultSet.TYPE_SCROLL_INSENSITIVE,
      ResultSet.CONCUR_UPDATABLE
  );
  ```

---

# 3) ResultSet types (cursor behavior)

* `TYPE_FORWARD_ONLY`

  * Cursor can only move forward using `next()` — lightest weight, default.
* `TYPE_SCROLL_INSENSITIVE`

  * Cursor can move forward & backward; does **not** reflect database changes after the query executed.
* `TYPE_SCROLL_SENSITIVE`

  * Scrollable and **may** reflect changes made to the underlying DB by other transactions (driver dependent).

---

# 4) Concurrency modes (update capability)

* `CONCUR_READ_ONLY` — read-only. `updateXxx()` methods will throw `SQLException`.
* `CONCUR_UPDATABLE` — allows updates via the ResultSet API (`updateRow()`, `insertRow()`, `deleteRow()`).

Note: Updatability depends on the query (must select key columns, etc.) and driver support.

---

# 5) Holdability

* Holdability controls whether a `ResultSet` remains open after a commit:

  * `ResultSet.HOLD_CURSORS_OVER_COMMIT` — cursor survives commit.
  * `ResultSet.CLOSE_CURSORS_AT_COMMIT` — cursor closed on commit.
* Defined when creating statements or via `Connection.createStatement(...)` overloads.

---

# 6) Navigation methods (cursor movement)

* `boolean next()` — move to next row; returns `true` if row exists.
* `boolean previous()` — move to previous row (scrollable only).
* `boolean first()` — move to first row.
* `boolean last()` — move to last row.
* `boolean absolute(int row)` — move to row number; positive from start, negative from end (`-1` = last).
* `boolean relative(int rows)` — move relative to current position (e.g., `relative(-2)`).
* `void beforeFirst()` — position before first row.
* `void afterLast()` — position after last row.
* `int getRow()` — returns current row number (1-based), 0 if beforeFirst/afterLast.

---

# 7) Reading data from current row

* Use typed getters by column label or index:

  ```java
  int id = rs.getInt("id");
  String name = rs.getString(2);
  double salary = rs.getDouble("salary");
  ```
* `wasNull()` — call after a getter to check if the last read SQL value was `NULL`.
* Important: JDBC column indices start at **1**, not 0.

---

# 8) Updatable `ResultSet` methods (for `CONCUR_UPDATABLE`)

* `void updateInt(String columnLabel, int x)` etc. — put new value into the current row buffer.
* `void updateRow()` — write buffered updates to the underlying database for the **current** row.
* `void moveToInsertRow()` — move cursor to a special row used for inserting.
* `void insertRow()` — insert the row created on the insert buffer into DB.
* `void deleteRow()` — delete current row from DB.
* `void moveToCurrentRow()` — return from insert buffer back to current row.

**Constraints & rules**

* Not all queries produce an updatable ResultSet: the `SELECT` must refer to a real table (not aggregated or joined in complex ways) and include the primary key (driver requirements vary).
* Driver and DB must support updatable result sets — many production apps prefer explicit `UPDATE/INSERT/DELETE` SQL for clarity and performance.

---

# 9) Metadata access

* `ResultSetMetaData rsmd = rs.getMetaData();`

  * `rsmd.getColumnCount()`
  * `rsmd.getColumnName(i)` / `getColumnLabel(i)`
  * `rsmd.getColumnTypeName(i)` — data type name (VARCHAR, INT, ...)
  * `rsmd.isNullable(i)`, `rsmd.isAutoIncrement(i)`, etc.
* Use this for dynamic code (e.g., generic grid display).

---

# 10) Typical lifecycle & resource handling

* Always close `ResultSet`, `Statement`, `Connection` — preferably with try-with-resources:

  ```java
  try (Connection con = DriverManager.getConnection(url, user, pass);
       Statement st = con.createStatement();
       ResultSet rs = st.executeQuery("SELECT ...")) {
       while (rs.next()) { ... }
  } // auto-closed
  ```
* Close order: `ResultSet` → `Statement` → `Connection` (try-with-resources handles it).
* Avoid long-running open `ResultSet` objects (locks, open cursors).

---

# 11) Hold & Concurrency example (creating statement)

```java
Statement st = con.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,
    ResultSet.CONCUR_UPDATABLE
);
```

---

# 12) Examples — read, update, insert, delete

**A. Simple forward-only read**

```java
try (Statement st = con.createStatement();
     ResultSet rs = st.executeQuery("SELECT id, name FROM students")) {
    while (rs.next()) {
        System.out.println(rs.getInt("id") + " - " + rs.getString("name"));
    }
}
```

**B. Scroll + absolute + previous**

```java
Statement st = con.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,
    ResultSet.CONCUR_READ_ONLY);
ResultSet rs = st.executeQuery("SELECT id, name FROM students");
if (rs.absolute(3)) {
    System.out.println("Row 3 -> " + rs.getInt("id"));
}
rs.afterLast();
while (rs.previous()) {
    // traverse backwards
}
```

**C. Updatable ResultSet — update first row**

```java
Statement st = con.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,
    ResultSet.CONCUR_UPDATABLE);
ResultSet rs = st.executeQuery("SELECT id, name FROM students WHERE id < 1000");
if (rs.first()) {
    rs.updateString("name", "NewName");
    rs.updateRow(); // persists change
}
```

**D. Insert using ResultSet**

```java
rs.moveToInsertRow();
rs.updateInt("id", 999);
rs.updateString("name", "Inserted");
rs.insertRow();
rs.moveToCurrentRow();
```

---

# 13) Performance & practical considerations

* `TYPE_FORWARD_ONLY` is fastest and uses least resources — prefer for simple reads.
* Scrollable and updatable ResultSets can be expensive and driver/DB dependent.
* For bulk updates/inserts prefer batched SQL (`PreparedStatement.addBatch()`) rather than updatable `ResultSet`.
* Large result sets: use `setFetchSize()` on `Statement` (hint to driver) and consider server-side cursors (driver specific).
* Avoid selecting unnecessary columns — fetch only needed fields.

---

# 14) Common exceptions & pitfalls

* `SQLException: ResultSet closed` — using `rs` after closing or after commit if holdability is `CLOSE_CURSORS_AT_COMMIT`.
* `SQLException: Operation not allowed on forward only result set` — trying to call `previous()` on `TYPE_FORWARD_ONLY`.
* `SQLException: ResultSet is not updatable` — query not updatable or `CONCUR_READ_ONLY`.
* `NullPointerException` if you pass a closed `Connection`/`Statement`.
* Wrong column index (0 or > columnCount) — JDBC indexes start at 1.

---

# 15) Interactions with transactions

* A `ResultSet` opened inside a transaction may see uncommitted data depending on isolation level and driver settings.
* If `ResultSet` holdability is `CLOSE_CURSORS_AT_COMMIT`, a `commit()` will close it; use `HOLD_CURSORS_OVER_COMMIT` to keep it open across commits (if supported).

---

# 16) Driver differences & portability

* Behavior of `TYPE_SCROLL_SENSITIVE`, updatable result sets, and holdability is **driver-dependent**. Test on the target DB (MySQL, Oracle, SQL Server).
* Always check driver docs for limitations (e.g., MySQL Connector/J historically had restrictions on updatable `ResultSet` behavior).

---

# 17) Useful `ResultSet` methods quick reference

| Purpose               | Method                                   |
| --------------------- | ---------------------------------------- |
| Move forward          | `next()`                                 |
| Move backward         | `previous()` (scrollable)                |
| Jump to absolute row  | `absolute(int)`                          |
| Move relative         | `relative(int)`                          |
| Go before first       | `beforeFirst()`                          |
| Go after last         | `afterLast()`                            |
| Get current row index | `getRow()`                               |
| Read column           | `getInt()`, `getString()`, `getObject()` |
| Check NULL            | `wasNull()`                              |
| Update column         | `updateXxx()` (updatable RS)             |
| Persist update        | `updateRow()`                            |
| Insert new row        | `moveToInsertRow()` + `insertRow()`      |
| Delete current row    | `deleteRow()`                            |
| Meta info             | `getMetaData()` → `ResultSetMetaData`    |

---

# 18) Example full program (reads metadata, demonstrates navigation & updatable)

```java
try (Connection con = DriverManager.getConnection(url, user, pass);
     Statement st = con.createStatement(
         ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
     ResultSet rs = st.executeQuery("SELECT id, name, age FROM students")) {

    // metadata
    ResultSetMetaData md = rs.getMetaData();
    int cols = md.getColumnCount();

    // print column names
    for (int i = 1; i <= cols; i++) {
        System.out.println(md.getColumnName(i) + " : " + md.getColumnTypeName(i));
    }

    // forward iterate
    while (rs.next()) { ... }

    // update first row
    if (rs.first()) {
        rs.updateString("name", "Updated");
        rs.updateRow();
    }

    // insert new
    rs.moveToInsertRow();
    rs.updateInt("id", 9999);
    rs.updateString("name", "New");
    rs.insertRow();
    rs.moveToCurrentRow();
}
```

---

# 19) When to use ResultSet features vs plain SQL

* Use `ResultSet` navigation for UI use-cases where a cursor is natural (paging via `absolute()` can be fine for small tables).
* Use `PreparedStatement` + `LIMIT/OFFSET` (or DB pagination) for scalable paging.
* Use `ResultSet` updatability sparingly — explicit `UPDATE`/`INSERT` SQL is clearer, more portable, and usually more efficient.

---

# 20) Short checklist for students (best practices)

* Use try-with-resources to auto-close.
* Prefer `PreparedStatement` for queries with parameters.
* Keep ResultSet lifetime short — close quickly.
* Use `TYPE_FORWARD_ONLY` for bulk reads.
* Test updatable/scrollable behavior on the target DB and driver.
* Use metadata (`ResultSetMetaData`) for generic display code.
* Use `setFetchSize()` for large result sets (driver dependent).

---

# 21) Sample `students` table (SQL) — quick test data

```sql
CREATE TABLE students (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  age INT,
  email VARCHAR(255),
  location VARCHAR(100)
);

INSERT INTO students VALUES
(1,'Ramu',21,'ramu@example.com','Hyderabad'),
(2,'Sita',22,'sita@example.com','Vijayawada'),
(3,'Anil',23,'anil@example.com','Guntur');
```

---

# 22) Quick troubleshooting tips

* If `previous()` fails: ensure your `Statement` created with `TYPE_SCROLL_*`.
* If `updateRow()` says not updatable: include primary key in `SELECT` and avoid complex joins.
* If metadata shows unexpected column names: use `getColumnLabel()` vs `getColumnName()` (alias vs actual name).

---

# 23) Summary

* `ResultSet` = cursor over query results. Default is forward-only read-only.
* Scrollable types let you move cursor arbitrarily but are heavier and driver-dependent.
* Updatable ResultSets allow in-place updates using `updateXxx()` / `insertRow()` / `deleteRow()` but require support and careful usage.
* Always close resources, prefer `PreparedStatement` and batched SQL for bulk operations, and test driver-specific behaviors.

