

## üîπ What is `PriorityQueue` in Java?

A **`PriorityQueue`** in Java is a **queue data structure** where **each element has a priority**. Elements are ordered based on their **natural order** (for example, numbers in ascending order) or a **custom comparator**.

>  Unlike a regular `Queue` (FIFO), the **highest priority element is removed first**.

---

## üîπ Declaration and Syntax

```java
import java.util.PriorityQueue;

PriorityQueue<Type> queueName = new PriorityQueue<>();
```

**Example:**

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
```

---

## üîπ Key Features

| Feature                      | Description                                   |
| ---------------------------- | --------------------------------------------- |
| **Not ordered by insertion** | Orders by priority (smallest/highest first)   |
| **Implements**               | `Queue` interface                             |
| **Not thread-safe**          | ‚ùå Not synchronized                            |
| **Duplicates allowed**       | ‚úÖ Yes                                         |
| **Null elements**            | ‚ùå Not allowed (throws `NullPointerException`) |
| **Internal structure**       | **Min-Heap** by default                       |

---

## üîπ Internal Working

* Internally uses a **binary heap** (Min-Heap by default).
* **Heap Invariant**: Root (head) is always the **smallest** or **highest priority**.
* Java's `PriorityQueue` is not a sorted list; only the **head** (first element to be removed) is guaranteed to be the highest priority.

---

## üîπ Commonly Used Methods

| Method                    | Description                                 |
| ------------------------- | ------------------------------------------- |
| `add(E e)` / `offer(E e)` | Inserts element                             |
| `poll()`                  | Removes and returns head (highest priority) |
| `peek()`                  | Returns head without removing               |
| `remove(Object o)`        | Removes specific object                     |
| `contains(Object o)`      | Checks if element exists                    |
| `size()`                  | Number of elements                          |
| `clear()`                 | Empties the queue                           |

---

## üîπ Example Program

```java
import java.util.PriorityQueue;

public class PriorityQueueExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        // Adding elements
        pq.add(40);
        pq.add(10);
        pq.add(30);
        pq.add(20);

        // Peek top element
        System.out.println("Top (smallest): " + pq.peek()); // 10

        // Polling elements (in order)
        while (!pq.isEmpty()) {
            System.out.println(pq.poll());
        }
    }
}
```

---

## üîπ Output:

```
Top (smallest): 10
10
20
30
40
```

---

## üîπ Real-World Use Cases

###  1. **Job Scheduling (CPU Scheduling)**

* Processes with higher priority are executed first.

###  2. **Dijkstra‚Äôs Algorithm (Graph Shortest Path)**

* Nodes with lowest distance are processed first.

###  3. **Data Stream Median**

* Min-Heap and Max-Heap combo.

###  4. **Customer Service Ticketing**

* Premium users get served before normal users.

---

## üîπ Using Custom Comparator

```java
PriorityQueue<Integer> maxPQ = new PriorityQueue<>((a, b) -> b - a);
maxPQ.add(10);
maxPQ.add(30);
maxPQ.add(20);
System.out.println(maxPQ.poll()); // 30 (highest first)
```

---

## üîπ PriorityQueue with Custom Class

```java
import java.util.*;

class Task {
    String name;
    int priority;

    Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    public String toString() {
        return name + " (Priority: " + priority + ")";
    }
}

public class CustomPQ {
    public static void main(String[] args) {
        PriorityQueue<Task> taskQueue = new PriorityQueue<>(
            (t1, t2) -> t1.priority - t2.priority  // ascending priority
        );

        taskQueue.add(new Task("Low-priority task", 5));
        taskQueue.add(new Task("High-priority task", 1));
        taskQueue.add(new Task("Medium-priority task", 3));

        while (!taskQueue.isEmpty()) {
            System.out.println(taskQueue.poll());
        }
    }
}
```

---

## üîπ PriorityQueue vs Other Collections

| Feature       | PriorityQueue      | Queue   | Stack      | ArrayList       |
| ------------- | ------------------ | ------- | ---------- | --------------- |
| Order         | By priority (heap) | FIFO    | LIFO       | Insertion order |
| Thread-safe   | ‚ùå No               | Depends | ‚úÖ (legacy) | ‚ùå No            |
| Null allowed  | ‚ùå No               | ‚úÖ Yes   | ‚úÖ Yes      | ‚úÖ Yes           |
| Random access | ‚ùå No               | ‚ùå No    | ‚ùå No       | ‚úÖ Yes           |

---

## üîπ Interview Points

* **Min-heap** is default behavior.
* Can build **Max-heap** using custom `Comparator`.
* **Head** of queue is **least** by default.
* **Null values are not allowed**.
* Best for problems involving **priority-based processing**.

---

## üîπ When to Use PriorityQueue?

Use it when:

* You need **priority-based access**.
* Don't need **random access** or maintain **insertion order**.
* Efficient **polling of top priority** element is required.

---

##  Summary

| Property          | Value                                                    |
| ----------------- | -------------------------------------------------------- |
| Order Type        | Priority (Min-Heap by default)                           |
| Thread-safe       | ‚ùå No                                                     |
| Null Allowed      | ‚ùå No                                                     |
| Duplicate Allowed | ‚úÖ Yes                                                    |
| Time Complexity   | `add()` ‚Äì O(log n), `poll()` ‚Äì O(log n), `peek()` ‚Äì O(1) |

