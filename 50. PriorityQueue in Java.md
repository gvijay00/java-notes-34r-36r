
# üî∑ Queue in Java 

### ‚úÖ Definition

A **Queue** is a **First-In-First-Out (FIFO)** linear data structure where:

* **Elements are added** from the **rear (tail)**.
* **Elements are removed** from the **front (head)**.

It is part of the **Java Collections Framework**, declared in `java.util`.

### ‚úÖ Common Implementations

| Class           | Characteristics                                   |
| --------------- | ------------------------------------------------- |
| `LinkedList`    | General-purpose FIFO queue. Allows null elements. |
| `PriorityQueue` | Orders by priority instead of insertion.          |
| `ArrayDeque`    | Faster alternative to Stack and LinkedList.       |

---

## üîπ Queue Syntax

```java
Queue<String> queue = new LinkedList<>();
```

---

## üîπ Queue Interface Methods

| Method      | Description                                                         |
| ----------- | ------------------------------------------------------------------- |
| `add(e)`    | Inserts element. Throws exception if queue is full.                 |
| `offer(e)`  | Inserts element. Returns `false` if insertion fails.                |
| `remove()`  | Removes and returns head. Throws `NoSuchElementException` if empty. |
| `poll()`    | Removes and returns head. Returns `null` if empty.                  |
| `element()` | Returns head without removing. Throws exception if empty.           |
| `peek()`    | Returns head without removing. Returns `null` if empty.             |
| `isEmpty()` | Checks if queue is empty.                                           |
| `size()`    | Returns number of elements.                                         |
| `clear()`   | Removes all elements.                                               |

---

## üîπ Queue Example

```java
import java.util.*;

public class QueueDemo {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        queue.add("A");
        queue.offer("B");
        queue.offer("C");

        System.out.println("Queue: " + queue);         // [A, B, C]
        System.out.println("Peek: " + queue.peek());   // A
        System.out.println("Removed: " + queue.remove()); // A
        System.out.println("Poll: " + queue.poll());   // B
        System.out.println("Now: " + queue);           // [C]
        System.out.println("Element: " + queue.element()); // C

        queue.clear();
        System.out.println("Is Empty? " + queue.isEmpty()); // true
    }
}
```

---

| **Method Pair**         | **Difference**                                                                                                                                     |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `add()` vs `offer()`    | üîπ `add()` throws an exception (`IllegalStateException`) if the queue is full. <br> üîπ `offer()` returns `false` instead of throwing an exception. |
| `remove()` vs `poll()`  | üîπ `remove()` throws an exception (`NoSuchElementException`) if the queue is empty. <br> üîπ `poll()` returns `null` if the queue is empty.         |
| `element()` vs `peek()` | üîπ `element()` throws an exception if the queue is empty. <br> üîπ `peek()` returns `null` if the queue is empty.                                   |


# üî∑ PriorityQueue in Java 

### ‚úÖ Definition

A `PriorityQueue` is a **special queue** where:

* **Elements are ordered by priority**, not by insertion.
* **Smallest or highest-priority element** is always at the head.

> Internally implemented using a **Min-Heap** (binary heap).

---

## üîπ Declaration

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
```

### ‚úÖ Characteristics

| Feature            | Value                                |
| ------------------ | ------------------------------------ |
| Ordering           | Natural order or custom comparator   |
| Null allowed?      | ‚ùå No (throws `NullPointerException`) |
| Thread-safe?       | ‚ùå No                                 |
| Duplicates?        | ‚úÖ Yes                                |
| Internal Structure | Min-Heap                             |

---

## üîπ Methods of PriorityQueue

| Method                | Description                               |
| --------------------- | ----------------------------------------- |
| `add(e)` / `offer(e)` | Inserts element (heap is restructured).   |
| `poll()`              | Removes and returns top-priority element. |
| `peek()`              | Returns top element without removing.     |
| `remove(Object o)`    | Removes specific object.                  |
| `contains(Object o)`  | Checks if element exists.                 |
| `size()`              | Number of elements.                       |
| `clear()`             | Removes all elements.                     |

---

## üîπ Basic Example

```java
import java.util.PriorityQueue;

public class PriorityQueueExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        pq.add(40);
        pq.add(10);
        pq.add(30);
        pq.add(20);

        System.out.println("Top Element: " + pq.peek()); // 10

        while (!pq.isEmpty()) {
            System.out.println(pq.poll()); // 10, 20, 30, 40
        }
    }
}
```

---

## üîπ PriorityQueue with Custom Comparator (Max-Heap)

```java
PriorityQueue<Integer> maxPQ = new PriorityQueue<>((a, b) -> b - a);
maxPQ.add(10);
maxPQ.add(30);
maxPQ.add(20);
System.out.println(maxPQ.poll()); // 30 (highest first)
```

---

## üîπ PriorityQueue with Custom Class

```java
import java.util.*;

class Task {
    String name;
    int priority;

    Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    public String toString() {
        return name + " (Priority: " + priority + ")";
    }
}

public class CustomPQ {
    public static void main(String[] args) {
        PriorityQueue<Task> taskQueue = new PriorityQueue<>(
            (t1, t2) -> t1.priority - t2.priority // Ascending priority
        );

        taskQueue.add(new Task("Low", 5));
        taskQueue.add(new Task("High", 1));
        taskQueue.add(new Task("Medium", 3));

        while (!taskQueue.isEmpty()) {
            System.out.println(taskQueue.poll());
        }
    }
}
```

---

## üîπ Real-Life Use Cases

| Use Case                 | How It Works                        |
| ------------------------ | ----------------------------------- |
| CPU Job Scheduling       | Higher-priority jobs run first.     |
| Dijkstra‚Äôs Algorithm     | Nodes with shortest distance first. |
| A\* Pathfinding          | Best node explored based on cost.   |
| Customer Support Systems | VIP tickets handled before others.  |
| Live Leaderboard Systems | Top scores maintained in heap.      |

---

## üîπ PriorityQueue vs Other Collections

| Feature       | PriorityQueue | Queue (LinkedList) | Stack      | ArrayList       |
| ------------- | ------------- | ------------------ | ---------- | --------------- |
| Order         | By priority   | FIFO               | LIFO       | Insertion order |
| Null allowed  | ‚ùå No          | ‚úÖ Yes              | ‚úÖ Yes      | ‚úÖ Yes           |
| Thread-safe   | ‚ùå No          | ‚ùå No               | ‚úÖ (Legacy) | ‚ùå No            |
| Random Access | ‚ùå No          | ‚ùå No               | ‚ùå No       | ‚úÖ Yes           |

---

## üîπ Interview Highlights

* Uses **Min-Heap** by default.
* Custom comparator = **Max-Heap** possible.
* `peek()` = O(1), `add()` and `poll()` = O(log n).
* No nulls allowed.
* Used in many **algorithmic problems**.

---

## üîπ Summary Table

| Property           | PriorityQueue                    |
| ------------------ | -------------------------------- |
| Order              | Priority-based (Min-Heap)        |
| Thread-safe        | ‚ùå No                             |
| Null allowed       | ‚ùå No                             |
| Duplicates allowed | ‚úÖ Yes                            |
| Time Complexity    | add/poll = O(log n), peek = O(1) |


